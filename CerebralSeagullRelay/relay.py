import numpy as np
import tensorflow as tf
import serial
import time
from scipy.signal import butter, filtfilt
from brainflow.board_shim import BoardShim, BrainFlowInputParams, BoardIds

# -----------------------------
# 1. Configuration
# -----------------------------
BOARD_ID = BoardIds.CYTON_BOARD.value
CYTON_PORT = "/dev/ttyUSB0"
STM32_PORT = "/dev/ttyACM0"
BAUD = 115200
FS = 250
WINDOW_SAMPLES = 125  # 0.5s window
CHANNEL = 1           # FP1 Channel


# -----------------------------
# 2. Load Model & Normalization
# -----------------------------
# Using TFLite for speed and compatibility
interpreter = tf.lite.Interpreter(model_path="blink_model.tflite")
interpreter.allocate_tensors()
input_details = interpreter.get_input_details()
output_details = interpreter.get_output_details()

# These must be the files generated by your training script
mean = np.load("mean.npy")
std = np.load("std.npy")

# -----------------------------
# 3. DSP Logic (Must match training!)
# -----------------------------
def butter_bandpass_filter(data, lowcut=1.0, highcut=15.0, fs=250, order=4):
    nyq = 0.5 * fs
    low = lowcut / nyq
    high = highcut / nyq
    b, a = butter(order, [low, high], btype='band')
    # filtfilt ensures zero-phase distortion for clean blink shapes
    return filtfilt(b, a, data)

def extract_features(w):
    w_clean = butter_bandpass_filter(w)
    dw = np.diff(w_clean)
    return np.array([
        np.max(w_clean) - np.min(w_clean), # Peak-to-peak
        np.max(np.abs(w_clean)),           # Max amplitude
        np.var(w_clean),                   # Variance
        np.sqrt(np.mean(w_clean ** 2)),    # RMS
        np.max(np.abs(dw)),                # Max derivative
    ], dtype=np.float32)

# -----------------------------
# 4. BrainFlow Setup & Recovery
# -----------------------------
params = BrainFlowInputParams()
params.serial_port = CYTON_PORT
board = BoardShim(BOARD_ID, params)

def init_board():
    try:
        if board.is_prepared():
            board.release_session()
        board.prepare_session()
        board.start_stream()
        return True
    except Exception as e:
        print(f"Error initializing board: {e}")
        return False

# -----------------------------
# 5. UART Setup
# -----------------------------
stm32 = serial.Serial(STM32_PORT, BAUD)

# -----------------------------
# 6. Live Blink Detection & UART Transmission
# -----------------------------
if init_board():
    print("\n--- Live Blink Detector Active ---")
    print(f"Relaying blink detection to STM32 on {STM32_PORT}...")
    print("Optimized for Normal Blinks (Sensitivity: 0.75)")
    
    rolling_buffer = np.zeros(WINDOW_SAMPLES)
    last_blink_time = 0
    DEBOUNCE_SEC = 0.4  # Ignore window overlaps for the same blink

    try:
        while True:
            # Get everything currently in the hardware buffer
            new_data = board.get_board_data()
            
            if new_data.size > 0:
                eeg_samples = new_data[CHANNEL]
                
                # Update the rolling window (Sliding Window approach)
                rolling_buffer = np.roll(rolling_buffer, -len(eeg_samples))
                rolling_buffer[-len(eeg_samples):] = eeg_samples

                # Extract and Normalize
                raw_feats = extract_features(rolling_buffer)
                norm_feats = (raw_feats - mean) / std
                input_data = norm_feats.reshape(1, 5).astype(np.float32)

                # Inference
                interpreter.set_tensor(input_details[0]['index'], input_data)
                interpreter.invoke()
                prob = interpreter.get_tensor(output_details[0]['index'])[0][0]

                # Determine blink status (0 or 1)
                current_time = time.time()
                blink_detected = 0
                
                if prob > 0.75 and (current_time - last_blink_time > DEBOUNCE_SEC):
                    blink_detected = 1
                    print(f"BLINK DETECTED! Prob: {prob:.2f}")
                    last_blink_time = current_time

                # Send blink status via UART: just a single byte (0 or 1)
                stm32.write(bytes([blink_detected]))
                stm32.flush()  # Ensure data is sent immediately

            time.sleep(0.01)  # High polling rate for responsiveness

    except KeyboardInterrupt:
        print("\nStopping detection.")
    finally:
        board.stop_stream()
        board.release_session()
        stm32.close()
else:
    print("Could not start session. Is the Cyton dongle plugged in?")
